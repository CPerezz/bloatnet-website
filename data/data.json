{
    "initial_metrics": [
        {
            "id": "read-write-performance-tree-depth",
            "title": "Read/Write Performance Speed vs Tree Depth",
            "category": "performance",
            "requester_badges": [
                "Stateless-Consensus",
                "Geth"
            ],
            "description": "It would be nice to know how performance for I/O gets degraded wrt the state growth and its size at each time."
        },
        {
            "id": "client-db-breaking-points",
            "title": "At Which State-Size Do Client-DBs Break?",
            "category": "database",
            "requester_badges": [
                "Stateless-Consensus",
                "Geth"
            ],
            "description": "It's important to know when and where client DB implementations will just break as they can't hold X[G/T]Bs of state. So that we see if things like e.g. sync or other things (OOM, etc) fail."
        },
        {
            "id": "block-creation-time-flamegraph",
            "title": "Block Creation Time & Flamegraph Analysis",
            "category": "execution",
            "requester_badges": [
                "Stateless-Consensus",
                "Geth"
            ],
            "description": "Will be interesting to see how execution time spent on blockbuilding/execution changes with gas_limit increases. How does the flamegraph look like? (computation, io, swapping, etc)."
        },
        {
            "id": "mpt-witness-multiproof-size",
            "title": "Size of MPT Witness (Multiproof)",
            "category": "witness",
            "requester_badges": [
                "Stateless-Consensus",
                "Geth"
            ],
            "description": "Likely not going to be severely impacted within the MPT as 3x'ing the DB will imply an increase in depth of ~2 levels. Nevertheless, is interesting to see the impact that this will cause for state change and for deep-depth tree value."
        }
    ],
    "additional_metrics": [
        {
            "id": "disk-ram-usage-gas-limit-day",
            "title": "Disk Growth & RAM Usage per Gas Limit & Day",
            "category": "resources",
            "requester_badges": [
                "Stateless-Consensus",
                "Geth"
            ],
            "description": "Self-explainatory metrics tracking disk growth and RAM usage on average per gas_limit and per day respectively."
        },
        {
            "id": "db-compaction-impact",
            "title": "DB Compaction Impact",
            "category": "database",
            "requester_badges": [
                "Stateless-Consensus",
                "Geth"
            ],
            "description": "Interesting to see the impacts on DB compaction that state-growth will cause and when. Would be interesting to have a client constantly running compaction or at least monitor closely what's the impact."
        },
        {
            "id": "sync-metrics-breaks-performance",
            "title": "Sync Metrics (When Sync Breaks & Performance)",
            "category": "sync",
            "requester_badges": [
                "Stateless-Consensus",
                "Geth"
            ],
            "description": "Test snap-sync with each client for every 100 GB?. Account for starting and final chain/DB size and speed of syncing as well as any issues. This should be performed WHILE the network is under heavy stress. To simulate real envs."
        },
        {
            "id": "cache-missing-rates",
            "title": "Cache Missing Rates",
            "category": "caching",
            "requester_badges": [
                "Stateless-Consensus",
                "Geth"
            ],
            "description": "It would be really interesting to get some data related to cache functioning wrt. state growth. Things like how cache poisoning affects next block execution are really valuable info on attack vectors that now seem unfeasible to perform."
        },
        {
            "id": "node-operator-resource-usage",
            "title": "Node Operator Resource Usage",
            "category": "resources",
            "requester_badges": [
                "Stateless-Consensus",
                "Geth"
            ],
            "description": "Comprehensive monitoring of disk I/O, network bandwidth, and computational requirements for running full nodes under increased load."
        },
        {
            "id": "transaction-confirmation-times",
            "title": "Transaction Confirmation Times",
            "category": "user-experience",
            "requester_badges": [
                "Stateless-Consensus",
                "Geth"
            ],
            "description": "Real-world transaction processing speeds under various network loads. Important for maintaining user experience as throughput increases."
        },
        {
            "id": "reth-desired-metrics",
            "title": "Reth's Desired Metrics",
            "category": "reth",
            "requester_badges": [
                "Reth"
            ],
            "description": "Metrics requested by the Reth team are still to be defined. This section will be updated once they provide their specific requirements."
        },
        {
            "id": "erigon-database-access-sload-sstore",
            "title": "Database Access Measurement (SLOAD/SSTORE)",
            "category": "erigon",
            "requester_badges": [
                "Erigon"
            ],
            "description": "Measure database Access (SLOAD/SSTORE) to understand how state operations impact performance and resource usage."
        },
        {
            "id": "erigon-state-root-computation-time",
            "title": "State Root Computation Time",
            "category": "erigon",
            "requester_badges": [
                "Erigon"
            ],
            "description": "Measure state root computation time to understand how this critical operation scales with state growth and affects overall performance."
        },
        {
            "id": "nethermind-desired-metrics",
            "title": "Nethermind's Desired Metrics",
            "category": "nethermind",
            "requester_badges": [
                "Nethermind"
            ],
            "description": "Metrics requested by the Nethermind team are still to be defined. This section will be updated once they provide their specific requirements."
        },
        {
            "id": "besu-state-access-percentage-sload",
            "title": "Percentage of State Accesses (SLOAD) in Block Execution",
            "category": "besu",
            "requester_badges": [
                "Besu"
            ],
            "description": "This should be checked with different gas limits, and different state sizes and for similar blocks. Understanding how much of block execution time is spent on state accesses."
        },
        {
            "id": "besu-state-root-hash-calculation",
            "title": "State Root Hash Calculation Performance",
            "category": "besu",
            "requester_badges": [
                "Besu"
            ],
            "description": "Do EL clients have the same throughput (mgas/s) with higher gas limit? And if no, is it only related to state growth?"
        },
        {
            "id": "besu-gas-limit-breaking-points-hardware",
            "title": "Gas Limit Breaking Points on Predefined Hardware",
            "category": "besu",
            "requester_badges": [
                "Besu"
            ],
            "description": "What gas limit makes EL clients break on a predefined hardware, like a 32 GiB machine. Use Hardware and Bandwidth recommendations from EIP 9270 to see when different EL clients break due to state being too big."
        }
    ],
    "categories": {
        "performance": {
            "name": "Performance",
            "color": "#a855f7",
            "icon": "âš¡"
        },
        "database": {
            "name": "Database",
            "color": "#3b82f6",
            "icon": "ðŸ’¾"
        },
        "execution": {
            "name": "Execution",
            "color": "#10b981",
            "icon": "ðŸ”„"
        },
        "witness": {
            "name": "Witness",
            "color": "#f59e0b",
            "icon": "ðŸ“‹"
        },
        "resources": {
            "name": "Resources",
            "color": "#ef4444",
            "icon": "ðŸ“Š"
        },
        "sync": {
            "name": "Synchronization",
            "color": "#84cc16",
            "icon": "ðŸ”„"
        },
        "caching": {
            "name": "Caching",
            "color": "#ec4899",
            "icon": "âš¡"
        },
        "user-experience": {
            "name": "User Experience",
            "color": "#06b6d4",
            "icon": "ðŸ‘¥"
        },
        "reth": {
            "name": "Reth",
            "color": "#f97316",
            "icon": "ðŸ¦€"
        },
        "erigon": {
            "name": "Erigon",
            "color": "#06b6d4",
            "icon": "ðŸš€"
        },
        "nethermind": {
            "name": "Nethermind",
            "color": "#10b981",
            "icon": "âš¡"
        },
        "besu": {
            "name": "Besu",
            "color": "#3b82f6",
            "icon": "â˜•"
        }
    },
    "requesters": {
        "Stateless-Consensus": {
            "name": "Stateless-Consensus",
            "color": "#a855f7",
            "url": "https://stateless.fyi/"
        },
        "Geth": {
            "name": "Geth",
            "color": "#8b5cf6",
            "url": "https://geth.ethereum.org/"
        },
        "Reth": {
            "name": "Reth",
            "color": "#f97316",
            "url": "https://reth.rs/"
        },
        "Erigon": {
            "name": "Erigon",
            "color": "#06b6d4",
            "url": "https://erigon.tech/"
        },
        "Nethermind": {
            "name": "Nethermind",
            "color": "#10b981",
            "url": "https://nethermind.io/"
        },
        "Besu": {
            "name": "Besu",
            "color": "#3b82f6",
            "url": "https://besu.hyperledger.org/"
        }
    }
}