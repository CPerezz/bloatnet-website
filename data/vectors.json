{
    "attack_vectors": [
        {
            "id": "warm-extcodesize-24kb",
            "rank": 1,
            "rank_badge": "ü•á",
            "technique_name": "100 gas warm EXTCODESIZE probe on 24KiB contracts",
            "technique_detail": "Warm EXTCODESIZE operation on large contracts",
            "cost_per_transient_byte": "240 g/B",
            "cost_calculation": "100 gas √∑ 24,576 B",
            "details": {
                "net_persistent_state": "0 B",
                "bytes_read_written": "24 KiB read",
                "intrinsic_gas": "100 gas per EXTCODESIZE",
                "max_units_30m_gas": "300,000 calls ‚Üí 300,000 √ó 24KiB = 6.72GiB bytes read",
                "technical_notes": "EXTCODESIZE is priced really low, and requires the node to load the code even if storage is warm. As the node needs to count the bytes. That allows for an insane amount of data to be read while executing"
            }
        },
        {
            "id": "cold-extcodesize-24kb",
            "rank": 2,
            "rank_badge": "ü•à",
            "technique_name": "2600 gas cold EXTCODESIZE probe on 24KiB contracts",
            "technique_detail": "Cold EXTCODESIZE operation on large contracts",
            "cost_per_transient_byte": "9.45 g/B",
            "cost_calculation": "2,600 gas √∑ 24,576 B",
            "details": {
                "net_persistent_state": "0 B",
                "bytes_read_written": "24 KiB read",
                "intrinsic_gas": "2,600 gas per EXTCODESIZE",
                "max_units_30m_gas": "11,538 calls ‚Üí 11,538 √ó 24KiB = 270.6MiB read",
                "technical_notes": "EXTCODESIZE is priced really low, and since the node doesn't cache the size of the bytecode, it actually needs to copy the whole bytecode to memory, count bytes then return the value. If the accounts aren't cached, this has chances to be quite disruptive when tries are massive and this can be abused more with higher gas limits"
            }
        },
        {
            "id": "sstore-zero-to-nonzero-back",
            "rank": 3,
            "rank_badge": "ü•â",
            "technique_name": "SSTORE 0‚Üíx then x‚Üí0 in the same tx",
            "technique_detail": "Storage manipulation with refund",
            "cost_per_transient_byte": "475 g/B",
            "cost_calculation": "(20,000 gas - 4,800 gas refund) √∑ 32 Bytes",
            "details": {
                "net_persistent_state": "0 B",
                "bytes_read_written": "64 Bytes written & erased",
                "intrinsic_gas": "20,000 gas - 4,800 gas refund = 15,200 gas net",
                "max_units_30m_gas": "Variable based on refund calculations",
                "technical_notes": "Refund now capped to 1‚ÅÑ5 of gas used (EIP-3529) so attack lost ¬æ of its edge"
            }
        }
    ],
    "persistent_attacks": [
        {
            "id": "database-corruption-attack",
            "attack": "Database corruption through state root manipulation",
            "description": "Exploits low-level database inconsistencies to corrupt state root calculations",
            "details": {
                "technical_notes": "This attack vector exploits race conditions in database write operations during high-throughput periods. By carefully timing transactions that modify overlapping state regions, attackers can cause database corruption that leads to inconsistent state root calculations across different client implementations.",
                "requires_raw_db_manipulation": true,
                "impact_level": "Critical",
                "difficulty": "Very High"
            }
        },
        {
            "id": "memory-exhaustion-attack",
            "attack": "Memory exhaustion through oversized trie structures",
            "description": "Forces client memory usage to spike by creating complex state trie patterns",
            "details": {
                "technical_notes": "This attack creates deeply nested storage patterns that force the client to maintain large portions of the state trie in memory simultaneously. By carefully crafting storage slot patterns that don't compress well, attackers can cause memory pressure leading to degraded performance or client crashes.",
                "requires_raw_db_manipulation": false,
                "impact_level": "High",
                "difficulty": "Medium"
            }
        },
        {
            "id": "consensus-desync-attack",
            "attack": "Consensus layer desynchronization via state inconsistencies",
            "description": "Exploits edge cases in state transitions to cause consensus layer issues",
            "details": {
                "technical_notes": "By triggering specific combinations of EVM operations during state transitions, this attack can cause subtle inconsistencies between execution and consensus layer state. This can lead to missed attestations, block proposals failures, or in extreme cases, temporary network splits.",
                "requires_raw_db_manipulation": false,
                "impact_level": "Critical",
                "difficulty": "High"
            }
        }
    ],
    "metadata": {
        "last_updated": "2024-12-19",
        "total_vectors": 3,
        "total_persistent_attacks": 3,
        "ranking_criteria": "Gas cost per transient byte (lowest to highest cost)",
        "note": "Lower cost is more efficient for attackers. Rankings focus on EXTCODESIZE exploits and storage manipulation attacks."
    }
}